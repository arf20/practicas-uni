***************** NOMBRE *******************
fmod NATURAL is

***************** CONJUNTOS ****************
    protecting BOOL .
    sort N .
    sort NoN .
    subsort NoN < N .

***************** SINTAXIS *****************
    op cero : -> N .
    op sucesor : N -> N .
    op suma : N N -> N .
    op esCero : N -> Bool .
    op esIgual : N N -> Bool .
    op esDistinto : N N -> Bool .

    op NODEFINIDO : -> NoN .
    op INFINITO : -> NoN .
    op NEGATIVO : -> NoN .

***************** SEMANTICA ****************
    var n m : N .

    eq suma(cero, n) = n .
    eq suma(sucesor(m), n) = sucesor(suma(m, n)) .
    eq esCero(cero) = true .
    eq esCero(sucesor(n)) = false .
    eq esIgual(cero, n) = esCero(n) .
    eq esIgual(sucesor(n), cero) = false .
    eq esIgual(sucesor(n), sucesor(m)) = esIgual(n, m) .
    eq esDistinto(n, m) = not esIgual(n, m) .
endfm


***************** NOMBRE *******************
fmod VOCAL is

***************** CONJUNTOS ****************
    protecting BOOL .
    sort V .

***************** SINTAXIS *****************
    ops A E I O U : -> V .
    op esIgual : V V -> Bool .
    op esDistinta : V V -> Bool .
    op esMenor : V V -> Bool .

***************** SEMANTICA ****************
    var v w : V .

    eq esIgual(v, v) = true .
    eq esIgual(v, w) = false .
    eq esDistinta(v, w) = not esIgual(v, w) .
    eq esMenor(v, v) = false .
    eq esMenor(A, v) = true .
    eq esMenor(v, A) = false .
    eq esMenor(E, v) = true .
    eq esMenor(v, E) = false .
    eq esMenor(I, v) = true .
    eq esMenor(v, I) = false .
    eq esMenor(O, v) = true .
    eq esMenor(v, O) = false .
    eq esMenor(U, v) = true .
    eq esMenor(v, U) = false .
endfm


***************** NOMBRE *******************
fmod BOLSA is

***************** CONJUNTOS ****************
    protecting BOOL .
    protecting NATURAL .
    protecting VOCAL .
    sort B .

***************** SINTAXIS *****************
    op bolsaVacia : -> B .
    op esVacia : B -> Bool .
    op insertar : V B -> B .
    op contar : V B -> N .
    op eliminar : V B -> B .

    op esMiembro : V B -> Bool .

    op union : B B -> B .
    op interseccion : B B -> B .


***************** SEMANTICA ****************
    var v w : V .
    var b c : B .

    eq esVacia(bolsaVacia) = true .
    eq esVacia(insertar(v, b)) = false .
    eq contar(v, bolsaVacia) = cero .
    eq contar(v, insertar(w, c)) = if esIgual(v, w) then sucesor(contar(v, c)) else contar(v, c) fi .
    eq eliminar(v, bolsaVacia) = bolsaVacia .
    eq eliminar(v, insertar(v, c)) = c .
    eq eliminar(v, insertar(w, c)) = insertar(w, eliminar(v, c)) .

    eq union(bolsaVacia, bolsaVacia) = bolsaVacia .
    eq union(bolsaVacia, insertar(v, bolsaVacia)) = insertar(v, bolsaVacia) .
    eq union(insertar(v, bolsaVacia), bolsaVacia) = insertar(v, bolsaVacia) .
    eq union(insertar(v, b), insertar(v, c)) = insertar(v, insertar(v, union(b, c))) .
    eq union(insertar(v, b), c) = insertar(v, union(b, c)) .
    eq union(b, insertar(v, c)) = insertar(v, union(b, c)) .

    eq esMiembro(v, bolsaVacia) = false .
    eq esMiembro(v, insertar(w, c)) = esIgual(v, w) or esMiembro(v, c) .
    
    eq interseccion(bolsaVacia, bolsaVacia) = bolsaVacia .
    eq interseccion(bolsaVacia, c) = bolsaVacia .
    eq interseccion(c, bolsaVacia) = bolsaVacia .
    eq interseccion(b, insertar(v, c)) = if esMayor(contar(v, b), contar(v, c)) then 

endfm
