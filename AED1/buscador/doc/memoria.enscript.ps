%!PS-Adobe-3.0
%%BoundingBox: 18 36 577 806
%%Title: Enscript Output
%%Creator: GNU Enscript 1.6.5.90
%%CreationDate: Wed Nov 27 12:39:31 2024
%%Orientation: Portrait
%%Pages: (atend)
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: (atend)
%%EndComments
%%BeginProlog
%%BeginResource: procset Enscript-Prolog 1.6.5 90
%
% Procedures.
%

/_S {	% save current state
  /_s save def
} def
/_R {	% restore from saved state
  _s restore
} def

/S {	% showpage protecting gstate
  gsave
  showpage
  grestore
} bind def

/MF {	% fontname newfontname -> -	make a new encoded font
  /newfontname exch def
  /fontname exch def

  /fontdict fontname findfont def
  /newfont fontdict maxlength dict def

  fontdict {
    exch
    dup /FID eq {
      % skip FID pair
      pop pop
    } {
      % copy to the new font dictionary
      exch newfont 3 1 roll put
    } ifelse
  } forall

  newfont /FontName newfontname put

  % insert only valid encoding vectors
  encoding_vector length 256 eq {
    newfont /Encoding encoding_vector put
  } if

  newfontname newfont definefont pop
} def

/MF_PS { % fontname newfontname -> -	make a new font preserving its enc
  /newfontname exch def
  /fontname exch def

  /fontdict fontname findfont def
  /newfont fontdict maxlength dict def

  fontdict {
    exch
    dup /FID eq {
      % skip FID pair
      pop pop
    } {
      % copy to the new font dictionary
      exch newfont 3 1 roll put
    } ifelse
  } forall

  newfont /FontName newfontname put

  newfontname newfont definefont pop
} def

/SF { % fontname width height -> -	set a new font
  /height exch def
  /width exch def

  findfont
  [width 0 0 height 0 0] makefont setfont
} def

/SUF { % fontname width height -> -	set a new user font
  /height exch def
  /width exch def

  /F-gs-user-font MF
  /F-gs-user-font width height SF
} def

/SUF_PS { % fontname width height -> -	set a new user font preserving its enc
  /height exch def
  /width exch def

  /F-gs-user-font MF_PS
  /F-gs-user-font width height SF
} def

/M {moveto} bind def
/s {show} bind def

/Box {	% x y w h -> -			define box path
  /d_h exch def /d_w exch def /d_y exch def /d_x exch def
  d_x d_y  moveto
  d_w 0 rlineto
  0 d_h rlineto
  d_w neg 0 rlineto
  closepath
} def

/bgs {	% x y height blskip gray str -> -	show string with bg color
  /str exch def
  /gray exch def
  /blskip exch def
  /height exch def
  /y exch def
  /x exch def

  gsave
    x y blskip sub str stringwidth pop height Box
    gray setgray
    fill
  grestore
  x y M str s
} def

/bgcs { % x y height blskip red green blue str -> -  show string with bg color
  /str exch def
  /blue exch def
  /green exch def
  /red exch def
  /blskip exch def
  /height exch def
  /y exch def
  /x exch def

  gsave
    x y blskip sub str stringwidth pop height Box
    red green blue setrgbcolor
    fill
  grestore
  x y M str s
} def

% Highlight bars.
/highlight_bars {	% nlines lineheight output_y_margin gray -> -
  gsave
    setgray
    /ymarg exch def
    /lineheight exch def
    /nlines exch def

    % This 2 is just a magic number to sync highlight lines to text.
    0 d_header_y ymarg sub 2 sub translate

    /cw d_output_w cols div def
    /nrows d_output_h ymarg 2 mul sub lineheight div cvi def

    % for each column
    0 1 cols 1 sub {
      cw mul /xp exch def

      % for each rows
      0 1 nrows 1 sub {
        /rn exch def
        rn lineheight mul neg /yp exch def
        rn nlines idiv 2 mod 0 eq {
	  % Draw highlight bar.  4 is just a magic indentation.
	  xp 4 add yp cw 8 sub lineheight neg Box fill
	} if
      } for
    } for

  grestore
} def

% Line highlight bar.
/line_highlight {	% x y width height gray -> -
  gsave
    /gray exch def
    Box gray setgray fill
  grestore
} def

% Column separator lines.
/column_lines {
  gsave
    .1 setlinewidth
    0 d_footer_h translate
    /cw d_output_w cols div def
    1 1 cols 1 sub {
      cw mul 0 moveto
      0 d_output_h rlineto stroke
    } for
  grestore
} def

% Column borders.
/column_borders {
  gsave
    .1 setlinewidth
    0 d_footer_h moveto
    0 d_output_h rlineto
    d_output_w 0 rlineto
    0 d_output_h neg rlineto
    closepath stroke
  grestore
} def

% Do the actual underlay drawing
/draw_underlay {
  ul_style 0 eq {
    ul_str true charpath stroke
  } {
    ul_str show
  } ifelse
} def

% Underlay
/underlay {	% - -> -
  gsave
    0 d_page_h translate
    d_page_h neg d_page_w atan rotate

    ul_gray setgray
    ul_font setfont
    /dw d_page_h dup mul d_page_w dup mul add sqrt def
    ul_str stringwidth pop dw exch sub 2 div ul_h_ptsize -2 div moveto
    draw_underlay
  grestore
} def

/user_underlay {	% - -> -
  gsave
    ul_x ul_y translate
    ul_angle rotate
    ul_gray setgray
    ul_font setfont
    0 0 ul_h_ptsize 2 div sub moveto
    draw_underlay
  grestore
} def

% Page prefeed
/page_prefeed {		% bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} def

% Wrapped line markers
/wrapped_line_mark {	% x y charwith charheight type -> -
  /type exch def
  /h exch def
  /w exch def
  /y exch def
  /x exch def

  type 2 eq {
    % Black boxes (like TeX does)
    gsave
      0 setlinewidth
      x w 4 div add y M
      0 h rlineto w 2 div 0 rlineto 0 h neg rlineto
      closepath fill
    grestore
  } {
    type 3 eq {
      % Small arrows
      gsave
        .2 setlinewidth
        x w 2 div add y h 2 div add M
        w 4 div 0 rlineto
        x w 4 div add y lineto stroke

        x w 4 div add w 8 div add y h 4 div add M
        x w 4 div add y lineto
	w 4 div h 8 div rlineto stroke
      grestore
    } {
      % do nothing
    } ifelse
  } ifelse
} def

% EPSF import.

/BeginEPSF {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack
  userdict begin
  /showpage { } def
  0 setgray 0 setlinecap
  1 setlinewidth 0 setlinejoin
  10 setmiterlimit [ ] 0 setdash newpath
  /languagelevel where {
    pop languagelevel
    1 ne {
      false setstrokeadjust false setoverprint
    } if
  } if
} bind def

/EndEPSF {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse
%%EndResource
%%BeginResource: procset Enscript-Encoding-88591 1.6.5 90
/encoding_vector [
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/space        	/exclam       	/quotedbl     	/numbersign   	
/dollar       	/percent      	/ampersand    	/quoteright   	
/parenleft    	/parenright   	/asterisk     	/plus         	
/comma        	/hyphen       	/period       	/slash        	
/zero         	/one          	/two          	/three        	
/four         	/five         	/six          	/seven        	
/eight        	/nine         	/colon        	/semicolon    	
/less         	/equal        	/greater      	/question     	
/at           	/A            	/B            	/C            	
/D            	/E            	/F            	/G            	
/H            	/I            	/J            	/K            	
/L            	/M            	/N            	/O            	
/P            	/Q            	/R            	/S            	
/T            	/U            	/V            	/W            	
/X            	/Y            	/Z            	/bracketleft  	
/backslash    	/bracketright 	/asciicircum  	/underscore   	
/quoteleft    	/a            	/b            	/c            	
/d            	/e            	/f            	/g            	
/h            	/i            	/j            	/k            	
/l            	/m            	/n            	/o            	
/p            	/q            	/r            	/s            	
/t            	/u            	/v            	/w            	
/x            	/y            	/z            	/braceleft    	
/bar          	/braceright   	/tilde        	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/space        	/exclamdown   	/cent         	/sterling     	
/currency     	/yen          	/brokenbar    	/section      	
/dieresis     	/copyright    	/ordfeminine  	/guillemotleft	
/logicalnot   	/hyphen       	/registered   	/macron       	
/degree       	/plusminus    	/twosuperior  	/threesuperior	
/acute        	/mu           	/paragraph    	/bullet       	
/cedilla      	/onesuperior  	/ordmasculine 	/guillemotright	
/onequarter   	/onehalf      	/threequarters	/questiondown 	
/Agrave       	/Aacute       	/Acircumflex  	/Atilde       	
/Adieresis    	/Aring        	/AE           	/Ccedilla     	
/Egrave       	/Eacute       	/Ecircumflex  	/Edieresis    	
/Igrave       	/Iacute       	/Icircumflex  	/Idieresis    	
/Eth          	/Ntilde       	/Ograve       	/Oacute       	
/Ocircumflex  	/Otilde       	/Odieresis    	/multiply     	
/Oslash       	/Ugrave       	/Uacute       	/Ucircumflex  	
/Udieresis    	/Yacute       	/Thorn        	/germandbls   	
/agrave       	/aacute       	/acircumflex  	/atilde       	
/adieresis    	/aring        	/ae           	/ccedilla     	
/egrave       	/eacute       	/ecircumflex  	/edieresis    	
/igrave       	/iacute       	/icircumflex  	/idieresis    	
/eth          	/ntilde       	/ograve       	/oacute       	
/ocircumflex  	/otilde       	/odieresis    	/divide       	
/oslash       	/ugrave       	/uacute       	/ucircumflex  	
/udieresis    	/yacute       	/thorn        	/ydieresis    	
] def
%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Courier
/HFpt_w 10 def
/HFpt_h 10 def
/Courier-Bold /HF-gs-font MF
/HF /HF-gs-font findfont [HFpt_w 0 0 HFpt_h 0 0] makefont def
/Courier /F-gs-font MF
/F-gs-font 10 10 SF
/#copies 1 def
% Pagedevice definitions:
gs_languagelevel 1 gt {
  <<
    /PageSize [595 842] 
  >> setpagedevice
} if
/d_page_w 559 def
/d_page_h 770 def
/d_header_x 0 def
/d_header_y 770 def
/d_header_w 559 def
/d_header_h 0 def
/d_footer_x 0 def
/d_footer_y 0 def
/d_footer_w 559 def
/d_footer_h 0 def
/d_output_w 559 def
/d_output_h 770 def
/cols 1 def
%%EndSetup
%%Page: (1) 1
%%BeginPageSetup
_S
18 36 translate
/pagenum 1 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 1) s
5 493 M
(                        MEMORIA PROYECTO BUSCADOR) s
5 482 M
(                            AED1    Nov, 2024) s
5 471 M
(                           \301ngel Ruiz Fernandez) s
5 460 M
(                            Carla Ramos Garc\355a) s
5 449 M
(                                G2.2 B117) s
_R
S
%%Page: (2) 2
%%BeginPageSetup
_S
18 36 translate
/pagenum 2 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 2) s
5 735 M
(MEMORIA) s
5 724 M
(    1. Analisis del programa .........................................   3) s
5 713 M
(        1.1. Clases ..................................................   3) s
5 702 M
(        1.2. Modulos .................................................   4) s
5 691 M
(        1.3. Makefile ................................................   5) s
5 680 M
(        1.4. Normalizaci\363n ...........................................   5) s
5 669 M
(        1.5. Tabla de dispersi\363n .....................................   5) s
5 658 M
(            1.5.1. Tipo ..............................................   5) s
5 647 M
(            1.5.2. Funci\363n de dispersi\363n .............................   5) s
5 636 M
(            1.5.4. Reestructuraci\363n ..................................   6) s
5 625 M
(            1.5.3. Liberaci\363n ........................................   6) s
5 614 M
(        1.6. Arbol ...................................................   6) s
5 603 M
(            1.6.1. Tipo ..............................................   6) s
5 592 M
(            1.6.2. Definici\363n de arbol y nodo ........................   6) s
5 581 M
(            1.6.3. Referencia a paginas ..............................   6) s
5 570 M
(            1.6.4. Liberar ...........................................   6) s
5 559 M
(        1.7. Globales ................................................   6) s
5 548 M
(        1.8. ChatGPT .................................................   6) s
5 537 M
(    2. Listado del c\363digo ............................................   7) s
5 526 M
(    3. Informe de desarrollo .........................................   7) s
5 515 M
(    4. Conclusiones y valoraciones personales ........................   ) s
_R
S
%%Page: (3) 3
%%BeginPageSetup
_S
18 36 translate
/pagenum 3 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 3) s
5 735 M
(1. Analisis del programa) s
5 713 M
(1.1. Clases) s
5 702 M
(        ) s
5 691 M
( -  class Pagina    ) s
5 680 M
(    Representa una pagina, almacena su url, titulo, relevancia y contenido.) s
5 658 M
( -  class PagListIt : public std::list<Pagina>::iterator) s
5 647 M
(        Usa Pagina) s
5 636 M
(    Iterador heredado que implementa el operador '<' para poder ser ordenado) s
5 625 M
(    en un contenedor ordenado.) s
5 614 M
(    Representa una referencia a elemento de std::list<Pagina>) s
5 592 M
( -  struct nodo_trie_t) s
5 581 M
(        Usa PagListIt) s
5 570 M
(    Representa un nodo del arbol trie de palabras. De este cuelgan hijos en un) s
5 559 M
(    diccionario <char, nodo_trie_t>. Relaciona con una lista de referencias a) s
5 548 M
(    pagina \(PagListIt\).) s
5 526 M
( -  class Arbol) s
5 515 M
(        Usa PagListIt y nodo_trie_t) s
5 504 M
(    Contiene la estructura arbol oculta, y posibles operaciones sobre el.) s
5 482 M
( -  class Diccionario) s
5 471 M
(        Usa Pagina, PagListIt y Arbol) s
5 460 M
(    Contiene la estructura de tabla de dispersi\363n \(std::list<Pagina>[N]\),) s
5 449 M
(    su funci\363n de hash, y una instancia de Arbol.) s
5 438 M
(    Expone las posibles operaciones sobre la tabla, adem\341s de pasar las) s
5 427 M
(    operaciones del arbol.) s
5 416 M
(   ) s
5 405 M
(    ) s
5 394 M
(                +--------+) s
5 383 M
(                | Pagina |) s
5 372 M
(                +--------+) s
5 361 M
(                     |) s
5 350 M
(         +-----------+-------------+) s
5 339 M
(         V                         |) s
5 328 M
(   +-----------+                   |) s
5 317 M
(   | PagListIt |                   |) s
5 306 M
(   +-----------+                   |) s
5 295 M
(     |       |                     |) s
5 284 M
(     |       |       +----+        |) s
5 273 M
(     |       V       V    |        |) s
5 262 M
(     |   +-------------+  |        |) s
5 251 M
(     |   | nodo_trie_t |  |        |) s
5 240 M
(     |   +-------------+  |        |) s
5 229 M
(     |       |       |    |        |) s
5 218 M
(     +---+---+       +----+        |) s
5 207 M
(         V                         |) s
5 196 M
(     +-------+                     |) s
5 185 M
(     | Arbol |                     |) s
5 174 M
(     +-------+                     |) s
5 163 M
(         |                         |) s
5 152 M
(         +------------+------------+) s
5 141 M
(                      V) s
5 130 M
(               +-------------+) s
5 119 M
(               + Diccionario |) s
5 108 M
(               +-------------+) s
5 86 M
(    Fig. 1 Diagrama de clases) s
_R
S
%%Page: (4) 4
%%BeginPageSetup
_S
18 36 translate
/pagenum 4 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 4) s
5 735 M
(1.2. Modulos) s
5 713 M
(Cada modulo \(menos main\) tiene un header asociado) s
5 691 M
( -  diccionario.hpp) s
5 680 M
(    Contiene la declaraci\363n de todas las clases y structs, interfaz para ser) s
5 669 M
(    usada por el interprete.) s
5 647 M
(    diccionario.cpp) s
5 636 M
(    Contiene la definici\363n de todos los metodos de las clases, que especifican) s
5 625 M
(    la estructura de datos y las operaciones asociadas de la base de datos.) s
5 603 M
( -  interprete.hpp) s
5 592 M
(    Contiene la declaraci\363n de las funciones que se encargan de interpretar) s
5 581 M
(    los comandos de la entrada.) s
5 559 M
(    interprete.cpp) s
5 548 M
(    Contiene la definici\363n de las funciones de interpretaci\363n de comandos,) s
5 537 M
(    que llaman a operaciones sobre el diccionario, que se le es pasado por) s
5 526 M
(    referencia.) s
5 504 M
( -  main.cpp) s
5 493 M
(    Contiene el bucle principal del programa, que lee comandos y llama al) s
5 482 M
(    interprete. Es propietario de la instanciaci\363n del dicionario, donde se) s
5 471 M
(    almacenan todos los datos de la aplicaci\363n.) s
5 438 M
(                                                    +-----------------+) s
5 427 M
(                                                    | diccionario.hpp |) s
5 416 M
(                                                    +-----------------+) s
5 405 M
(                                                            ^) s
5 394 M
(                                                            |) s
5 383 M
(              +---------------------+-----------------------+) s
5 372 M
(              |                     |                       |) s
5 361 M
(              |             +----------------+      +-----------------+) s
5 350 M
(              |             | interprete.hpp |      | diccionario.cpp |) s
5 339 M
(              |             +----------------+      +-----------------+) s
5 328 M
(              |                     ^) s
5 317 M
(              |                     |) s
5 306 M
(              +---------------------+) s
5 295 M
(              |                     |) s
5 284 M
(        +----------+        +----------------+) s
5 273 M
(        | main.cpp |        | interprete.cpp |) s
5 262 M
(        +----------+        +----------------+) s
5 240 M
(        main.o              interprete.o            diccionario.o) s
5 218 M
(        Fig 2. Diagrama de modulos y unidades de compilaci\363n) s
_R
S
%%Page: (5) 5
%%BeginPageSetup
_S
18 36 translate
/pagenum 5 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 5) s
5 735 M
(1.3. Makefile) s
5 713 M
(    En la Makefile, primero defino variables tales como el nombre del proyecto,) s
5 702 M
(el nombre de la salida, el compilador, y los parametros de compilador y linker;) s
5 691 M
(adem\341s de automaticamente guardar en SRC los archivos .cpp, de los cuales se) s
5 680 M
(saca el nombre de los archivos de objeto con un patsubst.) s
5 658 M
(    La regla all depende del binario de salida, que se crea en una regla de) s
5 647 M
(link que depende de los archivos de objeto. Los archivos de objeto se compilan) s
5 636 M
(en una regla patr\363n: para cada ".o" que depende de un ".cpp" y/o ".hpp", con el) s
5 625 M
(mismo nombre base.) s
5 603 M
(    Adicionalmente tengo reglas PHONY para realizar el test con la entrada) s
5 592 M
(de prueba, limpiar, crear el tarball, y subir a Mooshak con un script en python) s
5 581 M
(automatizado \(no incluido en el listado adjunto\).) s
5 570 M
(    ) s
5 559 M
(    La makefile contiene todas las dependencias existentes.) s
5 526 M
(1.4. Normalizaci\363n) s
5 504 M
(    Al parecer la gente no se da cuenta de que el lenguaje C++ soporta) s
5 493 M
(UTF-8 nativamente. Usando las variantes 'wide' o 'multibyte' de tipos y) s
5 482 M
(operaciones de la STL que soportan operar con estos caracteres Unicode) s
5 471 M
(como std::wcin/wcout, std::wstring \(std::basic_string<wchar_t>,) s
5 460 M
(y std::towlower\(\). Usando estas caracteristicas, la normalizaci\363n ser\355a trivial,) s
5 449 M
(el problema es que la especificaci\363n del programa requiere unas conversiones muy) s
5 438 M
(especificas que difieren del comportamiento de std::towlower\(\).) s
5 416 M
(    wchar_t std::towlower\(wchar_t\) convierte todos los caracteres con variante) s
5 405 M
(mayuscula a su variante minuscula, de todos los idiomas. La especificaci\363n) s
5 394 M
(indica que debemos normalizar solo los caracteres del Espa\361ol, ignorando el) s
5 383 M
(resto, por tanto primero se usa std::tolower\(\) que trabaja solo sobre ASCII) s
5 372 M
(\(ignorando Unicode\), y entonces despues, se manejan los casos para los) s
5 361 M
(caracteres especificos del espa\361ol, como las tildes y la '\361'.) s
5 328 M
(1.5. Tabla de dispersi\363n) s
5 306 M
(1.5.1. Tipo) s
5 284 M
(    El tipo elegido para la tabla de dispersi\363n es abierta, ya que es muy) s
5 273 M
(sencilla de implementar, y realmente porque las tablas cerradas no ofrecen) s
5 262 M
(ventajas significativas: con sets grandes, la optimizaci\363n de memoria es) s
5 251 M
(insignificante, y para tablas del mismo tama\361o, la cerrada es casi siempre m\341s) s
5 240 M
(lenta.) s
5 218 M
(1.5.2. Funci\363n de dispersi\363n) s
5 196 M
(    Al principio mientras probaba, sumaba todos los caracteres en un entero) s
5 185 M
(y aplicaba el modulo, esto conlleva una dispersi\363n bastante mala ya que las) s
5 174 M
(cadenas son de longitudes parecidas.) s
5 152 M
(    As\355 que se reemplaz\363 por una variante de un hash iterativo, donde el valor) s
5 141 M
(inicial t es un primo \(5381\), y por cada caracter de la cadena a hashear, se) s
5 130 M
(le suma a t desplazado 5 bits a la izquierda \(para aumentar la dispersi\363n\),) s
5 119 M
(con t, con el caracter. Finalmente se retorna t modulo tama\361o de la tabla. As\355) s
5 108 M
(la dispersi\363n es mucho m\341s uniforme.) s
_R
S
%%Page: (6) 6
%%BeginPageSetup
_S
18 36 translate
/pagenum 6 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 6) s
5 735 M
(1.5.3. Reestructuraci\363n) s
5 713 M
(    No se realiza reestructuraci\363n, se considera que el tama\361o de la tabla) s
5 702 M
(es suficiente para el numero de elementos.) s
5 680 M
(1.5.4. Liberaci\363n) s
5 658 M
(    No hay liberaci\363n explicita. Gracias a que la tabla es una propiedad array) s
5 647 M
(de un contenedor de la STL en la clase Diccionario, esta se elimina) s
5 636 M
(profundamente \(llamando automaticamente al destructor de cada contenedor\)) s
5 625 M
(al destruirse la instancia, que al estar siendo instanciada en la funci\363n) s
5 614 M
(main en el stack, se destruiye automaticamente al llegar al final de main\(\),) s
5 603 M
(antes de salir del programa, gracias a RAII de C++.) s
5 570 M
(1.6. Arbol) s
5 548 M
(1.6.1. Tipo) s
5 537 M
(    ) s
5 526 M
(    Se ha implementado un arbol Trie, ya que es muy simple de implementar, y lo) s
5 515 M
(bastante rapido para la aplicaci\363n. Buscar como maximo 26 elementos por) s
5 504 M
(caracter de palabra, usualmente menor que 15, es computacinalmente poco costoso.) s
5 493 M
(Implementar AVL no ofrecer\355a una ventaja clara en velocidad, costar\355a mas de) s
5 482 M
(implementar y el balanceo es computaci\363n extra.) s
5 460 M
(1.6.2. Definici\363n de arbol y nodo) s
5 438 M
(    El nodo es un struct, que contiene un std::set ordenado de referencias a) s
5 427 M
(paginas, y un diccionario de <wchar_t, nodo> hijos, para hacer el arbol.) s
5 405 M
(    La clase Arbol esconde en privado un diccionario como <wchar_t, nodo> como) s
5 394 M
(raiz de donde cuelgan todos los hijos, y expone solo 2 operaciones, insertar y) s
5 383 M
(buscar.) s
5 361 M
(1.6.3. Referencia a paginas) s
5 339 M
(    Las referencias a las paginas en los nodos del arbol son iteradores estandar) s
5 328 M
(de la STL, que usan punteros internamente.) s
5 306 M
(1.6.4. Liberaci\363n) s
5 284 M
(    Al igual que en la tabla de dispersi\363n, los diccionarios y conjuntos de los) s
5 273 M
(nodos se liberan automaticamente al destruirse la raiz, al destruirse la) s
5 262 M
(instancia de Arbol, al destruirse la instancia del Diccionario al final de) s
5 251 M
(main\(\).) s
5 229 M
(1.7. Globales) s
5 207 M
(    No se usa ning\372n tipo de variable ni constante global.) s
5 185 M
(1.8. ChatGPT) s
5 163 M
(    En ning\372n momento se ha usado ChatGPT para ninguna parte del proyecto,) s
5 152 M
(solo se han usado herramientas de depuraci\363n serias como gdb y valgrind, y) s
5 141 M
(recursos deterministas convencionales como investigar documentacion y posts en) s
5 130 M
(foros de desarrollo tales como StackoOverflow, escritos por el conocimiento,) s
5 119 M
(experiencia y sabidur\355a de personas humanas usadas a C++, gcc y sus) s
5 108 M
(intricaciones.) s
_R
S
%%Page: (7) 7
%%BeginPageSetup
_S
18 36 translate
/pagenum 7 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 7) s
5 735 M
(2. Listado completo del c\363digo) s
5 713 M
(    Veas\351 documento adjunto.) s
5 691 M
(3. Informe de desarrollo) s
5 669 M
(    El problema 001 fue muy trivial usando std::cin en un bucle.) s
5 647 M
(    Para el 002, como descrito en 1.4., me acord\351 de que C++ soporta Unicode) s
5 636 M
(nativamente, y usamos casos de caracteres unicode sobre wchar_t en vez de) s
5 625 M
(sobrecomplicarnos intentando decodificar caracteres multibyte manualmente, una) s
5 614 M
(practica poco recomendable.) s
5 592 M
(    En el siguiente, 003, se empez\363 a modularizar, creando el modulo interprete.) s
5 581 M
(En el main\(\) de la aplicaci\363n entonces, se abri\363 un bucle donde se lee un token) s
5 570 M
(mientras haya entrada disponible, y se llama al interprete para procesarlo.) s
5 559 M
(    El interprete, seg\372n el primer token en un switch, lee diferentes datos) s
5 548 M
(correspondiendose a los diferentes comandos, para los que hay que dar salidas de) s
5 537 M
(placeholder.) s
5 515 M
(    En el 004, se abre el modulo de diccionario, que se implementa con una \372nica) s
5 504 M
(gran lista ordenada en una nueva clase, Diccionario, que expone las apropiadas) s
5 493 M
(operaciones que se llaman desde el interprete.) s
5 482 M
(    En nuestro caso, decidimos usar un contenedor diccionario ordenado de la) s
5 471 M
(STL, std::map<std::wstring, Pagina> para simplificar las operaciones, .find\(\)) s
5 460 M
(para buscar a modo de lista, y .insert_or_assign\(\) para insertar o modificar) s
5 449 M
(cuando coincida la url.) s
5 438 M
(    El contenedor se ordena mediante un concepto un tanto extra\361o de C++,) s
5 427 M
(un objeto Compare de un contenedor ordenado. El struct comparador_paginas_url,) s
5 416 M
(que implementa un operator\(\), que recibe dos std::wstring y las compara usando) s
5 405 M
(el metodo indicado en la especificaci\363n \(.compare\(\) < 0\). De esta forma, al) s
5 394 M
(insertar en el diccionario, este se encarga de ordenar los elementos) s
5 383 M
(automaticamente. Otro concepto de C++ que se usa es std::optional<>, para cuando) s
5 372 M
(no se encuentra una pagina por url, no devolver nada.) s
5 361 M
(    Finalmente se implemnta el comando 'u' en el interprete usando las) s
5 350 M
(operaciones del diccionario, siendo pasado por referencia desde main\(\), el) s
5 339 M
(propietario del diccionario.) s
5 317 M
(    Para el 200, se nos pide implementar el diccionario con una tabla de) s
5 306 M
(dispersi\363n. Elegimos usar abierta por practicalidad, descrito en 1.5.1.) s
5 295 M
(Primero definimos la tabla como un array de cubetas de tipo std::vector \(esto) s
5 284 M
(cost\363 varias horas de depuraci\363n en el siguiente problema\) tal que) s
5 273 M
(std::vector<Pagina> tabla[N] siendo N el tama\361o de la tabla.) s
5 262 M
(    Despu\351s se implement\363 la funci\363n de hash de suma secuencial \(tambi\351n cost\363) s
5 251 M
(optimizaci\363n que tuvimos que hacer despues al mooshak reportar "Time limit) s
5 240 M
(exceeded"\), y las operaciones de insertar y consultar en la tabla usando esa) s
5 229 M
(funci\363n de hash. Corregimos el excesivo tiempo escogiendo una funci\363n de hash) s
5 218 M
(de mas calidad, cuyas caracteristicas son descritas en 1.5.1., y para optimizar) s
5 207 M
(el maximo posible, se revisaron ciertas cosas indicadas por la herramienta) s
5 196 M
(callgrind de valgrind, muy util.) s
5 185 M
(    Solo se tuvo que modificar el modulo diccionario para este problema.) s
5 163 M
(    En el 300, se defini\363 el nodo del arbol, y la clase Arbol, de tipo trie) s
5 152 M
(\(descrito en 1.6.1.\). el struct nodo_trie_t tiene 2 miembros, un vector de) s
5 141 M
(referencias \(iteradores, ya que son algo menos peligrosos que punteros de C, que) s
5 130 M
(no es buena practica usarlos en C++\) a paginas tal que) s
5 119 M
(std::vector<std::list<Pagina>::iterator>; notese std::list<Pagina>, pues tuvimos) s
5 108 M
(que cambiar las cubetas de la tabla de dispersi\363n a std::list en vez de) s
5 97 M
(std::vector \(el contenedor de referencias cambia en el problema siguiente\).) s
_R
S
%%Page: (8) 8
%%BeginPageSetup
_S
18 36 translate
/pagenum 8 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 8) s
5 735 M
(    El programa sufr\355a de fallos de segmento \(p\341gina, en realidad\), que ocurr\355an) s
5 724 M
(accediendo a las paginas mediante la referencia del arbol. gdb reportaba que las) s
5 713 M
(referencias al vector se volv\355an invalidas, tras un tiempo despu\351s de) s
5 702 M
(insertarlas. Tardamos un tiempo embarazoso en darnos cuenta de que, cuando se ) s
5 691 M
(inserta a un std::vector, todos los punteros y iteradores a sus elementos pueden) s
5 680 M
(ser invalidados, al sufrir un realloc. De manera que decidimos usar un) s
5 669 M
(std::list, cuyas referencias no se invalidan al insertar.) s
5 658 M
(    El otro miembro del nodo es un diccionario de otros nodos hijos formando el) s
5 647 M
(arbol, con clave wchar_t, de forma std::map<wchar_t, nodo_trie_t>.) s
5 636 M
(    La nueva clase Arbol, en privado tiene la raiz del arbol, que es) s
5 625 M
(directamente un std::map<wchar_t, nodo_trie_t>, y expone las dos operaciones) s
5 614 M
(\(descrito en 1.6.2.\) usadas por la clase Diccionario propietaria de su) s
5 603 M
(instancia, que wrapea las operaciones en su propia interfaz. Al insertar) s
5 592 M
(al arbol, las referencias se ordenan mediante std::sort y una funci\363n de) s
5 581 M
(comparaci\363n que toma iteradores a std::list<Pagina>.) s
5 570 M
(    En el interprete, se implementa el comando 'b' usando estas nuevas) s
5 559 M
(operaciones.) s
5 537 M
(    Decidimos realizar los problemas opcionales 301 y 302 por completitud.) s
5 515 M
(    Para realizar el 301 decidimos cambiar el contenedor de las referencias) s
5 504 M
(en el nodo del arbol a std::set, ya que as\355 podiamos aprovechar las funciones) s
5 493 M
(std::set_intersection \(y mas tarde std::set_union \(aunque este es muy facil) s
5 482 M
(de implementar insertando\)\) de la STL en la implementaci\363n del comando 'a',) s
5 471 M
(a partir del cual es trivial, iterando sobre los diferentes conjuntos de) s
5 460 M
(referencias, e irlos intersecando, de manera que queden solo los que est\341n en) s
5 449 M
(todos, implementando as\355 AND.) s
5 438 M
(    std::set al ser ordenado, ya no es necesario el uso de std::sort, pero si) s
5 427 M
(es necesario por ejemplo que el tipo del contenedor \(iterador\) tenga operator<\(\)) s
5 416 M
(definido con el fin comparar y ordenar. Para ello creamos otra clase, PagListIt,) s
5 405 M
(heredada de std::list<Pagina>::iterator, que implementa un constructor default) s
5 394 M
(del padre, necesario, y el operador, y se cambia el contenedor de refeencias de) s
5 383 M
(paginas en el nodo a std::set<PagListIt>.) s
5 361 M
(    Para el 302 fue trivial entonces usar std::set_union, uniendo los conjuntos) s
5 350 M
(de referencias en el comando 'o', mismo metodo que en el 301.) s
5 328 M
(    En el problema 303 se tuvo que implementar una nueva operaci\363n en el) s
5 317 M
(Arbol para buscar todas las palabras con un prefijo. Este m\351todo, llama a una) s
5 306 M
(funci\363n recursiva para recorrer todas las palabras que cuelgan de la secuencia) s
5 295 M
(de prefijo y insertarlas a un vector de tuplas de las palabras y el numero) s
5 284 M
(de referencias que contienen, tal que std::vector<std::pair<std::wstring, int>>.) s
5 273 M
(En el caller, ese vector resultante finalmente se ordena mediante std::sort) s
5 262 M
(y otra funci\363n de ordenaci\363n, y se devuelve.) s
_R
S
%%Page: (9) 9
%%BeginPageSetup
_S
18 36 translate
/pagenum 9 def
/fname () def
/fdir (.) def
/ftail (.) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
5 757 M
(MEMORIA PROYECTO BUSCADOR                                                  PAG 9) s
5 735 M
(    Proyecto: Buscador              Fecha de inicio: 14/10) s
5 724 M
(    Programadores: Angel, Carla     Fecha de finalizaci\363n: 19/11) s
5 702 M
(    +-------+----------+----------+--------+----------------+------------+) s
5 691 M
(    | D\315A*  | PROBLEMA | ANALISIS | DISE\321O | IMPLEMENTACI\323N | VALIDACI\323N |) s
5 680 M
(    +-------+----------+----------+--------+----------------+------------+) s
5 669 M
(    | 14/10 | 001      |        3 |      1 |              3 |          2 |) s
5 658 M
(    | 14/10 | 002      |        5 |     15 |             12 |          5 |) s
5 647 M
(    | 14/10 | 003      |        5 |      3 |             10 |          7 |) s
5 636 M
(    | 15/10 | 004      |       10 |     15 |             50 |         40 |) s
5 625 M
(    | 25/10 | 200      |        7 |     25 |             80 |         30 |) s
5 614 M
(    | 12/11 | 300      |       15 |     45 |            120 |         60 |) s
5 603 M
(    | 19/11 | 301      |        6 |     20 |             40 |          5 |) s
5 592 M
(    | 19/11 | 302      |        2 |      5 |              7 |          5 |) s
5 581 M
(    | 19/11 | 303      |       10 |     10 |             25 |          7 |) s
5 570 M
(    +-------+----------+----------+--------+----------------+------------+) s
5 559 M
(    | TOTAL |          |       58 |    139 |            347 |        161 |) s
5 548 M
(    | 705m  |          |          |        |                |            |) s
5 537 M
(    +-------+----------+----------+--------+----------------+------------+) s
5 515 M
(    Tabla 1. Dedicaci\363n temporal. Los tiempos est\341n en minutos y est\341n) s
5 504 M
(    basados en datos estimados. *D\315A de finalizaci\363n de implementaci\363n del) s
5 493 M
(    problema.) s
5 471 M
(4. Conclusiones y valoraciones personales) s
5 449 M
(   Al principio los problemas resultaron faciles, pero a partir de la tabla) s
5 438 M
(de dispersi\363n y el arbol, hubo que emplear bastante tiempo depurando y) s
5 427 M
(optimizando. Pensar\355as que no es posible tener segfaults usando solo la STL pero) s
5 416 M
(si. Si lo miras con valgrind, la STL comete memory leaks insalvables por su) s
5 405 M
(dise\361o y uso de templates. Si querian que usaramos punteros para los arboles y) s
5 394 M
(listas, el lenguaje para eso es C, no C++. ) s
5 372 M
(    Sin embargo, para usar C++, no se explican bien toda la funcionalidad que) s
5 361 M
(C++ ofrece. Parece que la mayor\355a no conoce si quiera que C++ soporta UTF-8;) s
5 350 M
(inmensamente \372til para la normalizaci\363n. No se explican los contenedores de la) s
5 339 M
(STL, cuando usarlos, sus propiedades y operaciones, tales como std::vector,) s
5 328 M
(std::list, std::deque, std::set, std::map...) s
5 306 M
(    Y tampoco se ense\361a el uso de depuradores como gdb y valgrind, herramientas) s
5 295 M
(inmensamente \372tiles y indispensables para desarrollo de cualquier software mas) s
5 284 M
(grande que una prueba.) s
5 262 M
(    Finalmente, este proyecto, cuyo objetivo era el uso practico de tablas de) s
5 251 M
(dispersi\363n y arboles, no es representativo del funcionamiento de un motor de) s
5 240 M
(busqueda real.) s
5 218 M
(    ) s
_R
S
%%Trailer
%%Pages: 9
%%DocumentNeededResources: font Courier-Bold Courier 
%%EOF
