proceso desde POV usuario -> irrelevante
proceso desde POV de sistema -> PCB (process control block) (linux: task.struct)

cada proceso tiene PCB
    cada proceso tiene una TP

PCB
    PID
    Tabla paginas
    signals
    Tabla canales
    etc...

vector de PCBs
en memoria
guarda todos los PCBs que el SO puede tener
PCBs usados y libres

procesos tienen estados: ready, run, blocked, zombie
proceso esta en ready cuando está encolado en cola de ready
blocked tiene muchas colas distintas
    cola de procesos esperando disco
    cola de procesos esperando red
    cola de procesos esperando timer
    etc...
procesos zombie son procesos que se han liberado los recursos de usuario por excepcion o exit() pero su PCB aun existen

ciclo de vida

    +-- RUN <-----+  
    v    |        |
  ZOMBIE |      READY
         v        ^
        BLOCKED --+

task_union y pila se solapan
pero task_union está al principio y la pila crece desde el final hacia el principio

union task_union {
    struct task_struct task;    // PCB
    unsigned long stack[8196];  // stack de proceso
}

struct task_struct {
    ...
    unsigned int *kernel_esp; // apunta al ebp de task_switch
    tp          // tabla paginas
    ...
}

la posicion de task_struct es alineada a pagina 0xXXXXX000

task_struct *current() {
    eax <= esp
    eax <= eax & 0xFFFFF000
}


usuario
-> viene interrupcion
handler
clock_routine
    scheduler() // <---- aqui 

    -> task_switch(union task_union *new)

void task_switch(union task_union *new) { push %ebp; mov %esp, %ebp
    %cr3 = new->task.tp;            // cambia el espacio de direcciones virtual al nuevo proceso
    tss.esp0 = &new->stack          // cambiar la pila de sistema en TSS para proxima interrupcion/cambio de privilegios
    current()->task.kernel_esp = %ebp;
    %esp = new->task.kernel_esp;    // cambiar esp a nueva pila; eso es lo que cambia el proceso
}   pop %ebp
    ret

las pilas de sistema siempre son accesibles porque los mapeos de sistema son siempre los mismos en las TPs de procesos
entonces el cr3 se puede tocar cuando sea, pero si se hace despues de setear %esp, es current() en vez de new
same para tss, tener en cuenta 

cambiar de pilas de sistema (esp) es cambiar de proceso
el write cr3 flushea la TLB para asegurar que no quedan mapeos viejos

siempre sabemos como están todas las pilas de sistema

PILA DE SISTEMA en task_switch
    ---------
task_union (top of stack) current
  kernel_esp
  | ...
  |
  +>ebp
    direccion de retorno rutina
    new (parametro)
    ... locales
    
    el ebp
    direccion de retorno handler
    contexto software
    contexto hardware

PILA DE SISTEMA de new
    ---------
    task_union (top of stack) new
    ...

    ebp
    direccion de retorno a rutina
    new
    ...

    ebp
    direccion torno handler
    contexto software
    contexto hardware

en modo usuario la pila de sistema está vacia, porque para volver a modo usuario se desapila todo contexto etc
y cuando se entra en modo sistema se vuelve a apilar todo



## paginación

%cr0 -> activar

%cr3 -> DIRECTORIO[1024] -> TP[1024]

init_mm() set up TPs


## scheduler

READYQ
FREEQ

crear procesos
INITPCBs
    init
    idle

double linked list de procesos

struct list_head {
    struct list_head *n, *p;
    struct task_struct *pcb'
}

struct task_struct {
    int pid;
    unsigned int *kernel_esp; // apunta al ebp de task_switch
    tp          // tabla paginas
    ???
    ...
}


sys_fork()
    asignar task_union
        TP
        memoria fisica
    asignar otros atributos
    inicializar contexto de ejecucion (task_struct padre = task_struct hijo)
    PID
    copiar memoria del padre al hijo
    preparar el proceso hijo para ejecucicion (poder entrar en run desde task_switch)
    informar scheduler (encolarlo en ready)
    devolver PID


SISTEMAS OPERATIVOS REENTRANTES
    sistemas que pueden aceptar interrupciones en modo sistema
    muy complicados, jugar con la pila

zeos:
    hacer EOI antes de clock_routine
    salir por las llamadas al sistema

    ret_from_fork() {
        return 0;
    }

cpu_idle() {
    sti
    while (1);
}

idle NO se mete en readyqueue




sys_fork()
    PCB libre
    copia memoria
    PID++


exit()
    tiene que liberar todos los recursos menos la PCB (task_union)
    en caso de que tengan hijos, tienen que pasar a ser hijos de otro proceso del sistema

wait()
    tiene hijos en cualquier estado?
        ninguno -> -1
        zombi -> libera task_union
        run/ready -> bloquear


